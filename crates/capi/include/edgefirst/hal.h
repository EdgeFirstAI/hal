#ifndef EDGEFIRST_HAL_H
#define EDGEFIRST_HAL_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @file hal.h
 * @brief EdgeFirst HAL C API
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) 2025 Au-Zone Technologies. All Rights Reserved.
 *
 * C API for EdgeFirst Hardware Abstraction Layer providing:
 * - Zero-copy tensor operations with DMA/SHM support
 * - Hardware-accelerated image processing (G2D, OpenGL, CPU)
 * - ML model output decoding (YOLO, ModelPack)
 * - Multi-object tracking (ByteTrack)
 *
 * @section error_handling Error Handling
 * Functions returning int: 0 on success, -1 on error (errno set)
 * Functions returning pointers: valid pointer on success, NULL on error (errno set)
 *
 * @section memory_management Memory Management
 * - hal_*_new() functions transfer ownership to caller (must call hal_*_free())
 * - hal_*_get_*() functions returning pointers are borrowed (valid during parent lifetime)
 * - hal_*_clone_fd() creates new owned fd (caller must close())
 * - hal_*_from_fd() takes ownership of fd (caller must NOT close())
 *
 * @section thread_safety Thread Safety
 * - All functions are thread-safe unless documented otherwise
 * - Tensor map operations require external synchronization when used concurrently
 */


/* Generated with cbindgen:0.29.2 */

/* WARNING: This file is auto-generated by cbindgen. Do not modify. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "stdint.h"
#include "stddef.h"
#include "stdbool.h"

/**
 * NMS (Non-Maximum Suppression) mode.
 */
typedef enum hal_nms {
  /**
   * Class-agnostic NMS: suppress overlapping boxes regardless of class
   */
  HAL_NMS_CLASS_AGNOSTIC = 0,
  /**
   * Class-aware NMS: only suppress boxes with the same class
   */
  HAL_NMS_CLASS_AWARE = 1,
  /**
   * No NMS (for end-to-end models with embedded NMS)
   */
  HAL_NMS_NONE = 2,
} hal_nms;

/**
 * Image pixel format (FourCC codes).
 */
typedef enum hal_fourcc {
  /**
   * 8-bit interleaved YUV422, limited range (YUYV)
   */
  HAL_FOURCC_YUYV = 0,
  /**
   * 8-bit planar YUV420, limited range (NV12)
   */
  HAL_FOURCC_NV12 = 1,
  /**
   * 8-bit planar YUV422, limited range (NV16)
   */
  HAL_FOURCC_NV16 = 2,
  /**
   * 8-bit RGBA (4 channels)
   */
  HAL_FOURCC_RGBA = 3,
  /**
   * 8-bit RGB (3 channels)
   */
  HAL_FOURCC_RGB = 4,
  /**
   * 8-bit grayscale, full range (Y800)
   */
  HAL_FOURCC_GREY = 5,
  /**
   * 8-bit planar RGB (3 planes)
   */
  HAL_FOURCC_PLANAR_RGB = 6,
  /**
   * 8-bit planar RGBA (4 planes)
   */
  HAL_FOURCC_PLANAR_RGBA = 7,
} hal_fourcc;

/**
 * Memory allocation type for tensors.
 *
 * Controls how tensor memory is allocated. DMA is recommended for hardware
 * acceleration, while MEM is the fallback for all platforms.
 */
typedef enum hal_tensor_memory {
  /**
   * Regular system memory allocation (available on all platforms)
   */
  HAL_TENSOR_MEMORY_MEM = 0,
  /**
   * Direct Memory Access allocation (Linux only, enables hardware acceleration)
   */
  HAL_TENSOR_MEMORY_DMA = 1,
  /**
   * POSIX Shared Memory allocation (Linux only, for IPC)
   */
  HAL_TENSOR_MEMORY_SHM = 2,
} hal_tensor_memory;

/**
 * Image rotation angles.
 */
typedef enum hal_rotation {
  /**
   * No rotation
   */
  HAL_ROTATION_NONE = 0,
  /**
   * 90 degrees clockwise
   */
  HAL_ROTATION_ROTATE90 = 1,
  /**
   * 180 degrees
   */
  HAL_ROTATION_ROTATE180 = 2,
  /**
   * 270 degrees clockwise (90 degrees counter-clockwise)
   */
  HAL_ROTATION_ROTATE270 = 3,
} hal_rotation;

/**
 * Image flip modes.
 */
typedef enum hal_flip {
  /**
   * No flip
   */
  HAL_FLIP_NONE = 0,
  /**
   * Vertical flip (top to bottom)
   */
  HAL_FLIP_VERTICAL = 1,
  /**
   * Horizontal flip (left to right)
   */
  HAL_FLIP_HORIZONTAL = 2,
} hal_flip;

/**
 * Data type of tensor elements.
 *
 * Used to query the type of elements stored in a tensor and interpret
 * the void* data pointer returned by hal_tensor_map_data().
 */
typedef enum hal_dtype {
  /**
   * Unsigned 8-bit integer (uint8_t)
   */
  HAL_DTYPE_U8 = 0,
  /**
   * Signed 8-bit integer (int8_t)
   */
  HAL_DTYPE_I8 = 1,
  /**
   * Unsigned 16-bit integer (uint16_t)
   */
  HAL_DTYPE_U16 = 2,
  /**
   * Signed 16-bit integer (int16_t)
   */
  HAL_DTYPE_I16 = 3,
  /**
   * Unsigned 32-bit integer (uint32_t)
   */
  HAL_DTYPE_U32 = 4,
  /**
   * Signed 32-bit integer (int32_t)
   */
  HAL_DTYPE_I32 = 5,
  /**
   * Unsigned 64-bit integer (uint64_t)
   */
  HAL_DTYPE_U64 = 6,
  /**
   * Signed 64-bit integer (int64_t)
   */
  HAL_DTYPE_I64 = 7,
  /**
   * 32-bit floating point (float)
   */
  HAL_DTYPE_F32 = 9,
  /**
   * 64-bit floating point (double)
   */
  HAL_DTYPE_F64 = 10,
} hal_dtype;

/**
 * Opaque ByteTrack tracker type.
 */
typedef struct hal_bytetrack hal_bytetrack;

/**
 * Opaque decoder type.
 */
typedef struct hal_decoder hal_decoder;

/**
 * Opaque decoder builder type.
 */
typedef struct hal_decoder_builder hal_decoder_builder;

/**
 * List of detection boxes.
 */
typedef struct hal_detect_box_list hal_detect_box_list;

/**
 * Opaque image processor type.
 *
 * The ImageProcessor handles format conversion with hardware acceleration when available.
 */
typedef struct hal_image_processor hal_image_processor;

/**
 * List of segmentation results.
 */
typedef struct hal_segmentation_list hal_segmentation_list;

/**
 * Type-erased tensor that can hold any supported data type.
 *
 * This is an opaque type - use hal_tensor_* functions to interact with it.
 */
typedef struct hal_tensor hal_tensor;

/**
 * Opaque tensor image type.
 *
 * A TensorImage combines a tensor with image format metadata (width, height, fourcc).
 */
typedef struct hal_tensor_image hal_tensor_image;

/**
 * Type-erased tensor map for CPU access to tensor data.
 *
 * This is an opaque type - use hal_tensor_map_* functions to interact with it.
 */
typedef struct hal_tensor_map hal_tensor_map;

/**
 * List of track info results.
 */
typedef struct hal_track_info_list hal_track_info_list;

/**
 * Detection box result.
 */
typedef struct hal_detect_box {
  /**
   * Left-most normalized coordinate (xmin)
   */
  float xmin;
  /**
   * Top-most normalized coordinate (ymin)
   */
  float ymin;
  /**
   * Right-most normalized coordinate (xmax)
   */
  float xmax;
  /**
   * Bottom-most normalized coordinate (ymax)
   */
  float ymax;
  /**
   * Confidence score
   */
  float score;
  /**
   * Class label index
   */
  size_t label;
} hal_detect_box;

/**
 * Rectangle structure for defining regions.
 */
typedef struct hal_rect {
  /**
   * Left edge (x coordinate)
   */
  size_t left;
  /**
   * Top edge (y coordinate)
   */
  size_t top;
  /**
   * Width of the rectangle
   */
  size_t width;
  /**
   * Height of the rectangle
   */
  size_t height;
} hal_rect;

/**
 * Crop configuration for image conversion.
 *
 * Specifies source crop region, destination placement, and background color.
 */
typedef struct hal_crop {
  /**
   * Source rectangle to crop from
   */
  struct hal_rect src_rect;
  /**
   * Destination rectangle to place crop into
   */
  struct hal_rect dst_rect;
  /**
   * Background color (RGBA)
   */
  uint8_t dst_color[4];
  /**
   * Whether src_rect is set
   */
  bool has_src_rect;
  /**
   * Whether dst_rect is set
   */
  bool has_dst_rect;
  /**
   * Whether dst_color is set
   */
  bool has_dst_color;
} hal_crop;

/**
 * Track information for a tracked object.
 */
typedef struct hal_track_info {
  /**
   * Unique identifier for this track (16 bytes UUID)
   */
  uint8_t uuid[16];
  /**
   * Predicted location in XYXY format (xmin, ymin, xmax, ymax)
   */
  float location[4];
  /**
   * Number of times this track has been updated
   */
  int32_t count;
  /**
   * Timestamp when this track was first created (nanoseconds)
   */
  uint64_t created;
  /**
   * Timestamp of the last update (nanoseconds)
   */
  uint64_t last_updated;
} hal_track_info;

/**
 * Create a new decoder builder.
 *
 * The builder starts with default values:
 * - Score threshold: 0.5
 * - IOU threshold: 0.5
 * - NMS: Class-agnostic
 *
 * A configuration must be set before building the decoder.
 *
 * @return New decoder builder handle on success, NULL on error
 * @par Errors (errno):
 * - ENOMEM: Memory allocation failed
 */
struct hal_decoder_builder *hal_decoder_builder_new(void);

/**
 * Set decoder configuration from a file (JSON or YAML).
 *
 * @param builder Decoder builder handle
 * @param path Path to configuration file
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL builder/path)
 * - ENOENT: File not found
 * - EBADMSG: Failed to parse configuration file
 */
int hal_decoder_builder_with_config_file(struct hal_decoder_builder *builder, const char *path);

/**
 * Set decoder configuration from a JSON string.
 *
 * @param builder Decoder builder handle
 * @param json_str JSON configuration string
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL builder/json_str)
 * - EBADMSG: Invalid JSON format
 */
int hal_decoder_builder_with_config_json(struct hal_decoder_builder *builder, const char *json_str);

/**
 * Set decoder configuration from a YAML string.
 *
 * @param builder Decoder builder handle
 * @param yaml_str YAML configuration string
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL builder/yaml_str)
 * - EBADMSG: Invalid YAML format
 */
int hal_decoder_builder_with_config_yaml(struct hal_decoder_builder *builder, const char *yaml_str);

/**
 * Set the score threshold for filtering detections.
 *
 * Detections with scores below this threshold are discarded.
 *
 * @param builder Decoder builder handle
 * @param threshold Score threshold (0.0 to 1.0)
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL builder)
 */
int hal_decoder_builder_with_score_threshold(struct hal_decoder_builder *builder, float threshold);

/**
 * Set the IOU threshold for NMS.
 *
 * Detection pairs with IOU above this threshold are candidates for suppression.
 *
 * @param builder Decoder builder handle
 * @param threshold IOU threshold (0.0 to 1.0)
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL builder)
 */
int hal_decoder_builder_with_iou_threshold(struct hal_decoder_builder *builder, float threshold);

/**
 * Set the NMS (Non-Maximum Suppression) mode.
 *
 * @param builder Decoder builder handle
 * @param nms NMS mode (HAL_NMS_*)
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL builder)
 */
int hal_decoder_builder_with_nms(struct hal_decoder_builder *builder, enum hal_nms nms);

/**
 * Build the decoder from the builder configuration.
 *
 * Consumes the builder - it cannot be used after this call.
 *
 * @param builder Decoder builder handle (consumed)
 * @return New decoder handle on success, NULL on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL builder) or no configuration set
 * - EBADMSG: Invalid configuration
 */
struct hal_decoder *hal_decoder_builder_build(struct hal_decoder_builder *builder);

/**
 * Free a decoder builder.
 *
 * @param builder Decoder builder handle to free (can be NULL, no-op)
 */
void hal_decoder_builder_free(struct hal_decoder_builder *builder);

/**
 * Decode model outputs into detection boxes.
 *
 * This is a simplified API for detection-only models with float outputs.
 *
 * @param decoder Decoder handle
 * @param outputs Array of output tensor pointers
 * @param num_outputs Number of output tensors
 * @param out_boxes Output parameter for detection box list (caller must free)
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL decoder/outputs/out_boxes)
 * - EIO: Decoding failed
 */
int hal_decoder_decode_float(const struct hal_decoder *decoder,
                             const struct hal_tensor *const *outputs,
                             size_t num_outputs,
                             struct hal_detect_box_list **out_boxes);

/**
 * Free a decoder.
 *
 * @param decoder Decoder handle to free (can be NULL, no-op)
 */
void hal_decoder_free(struct hal_decoder *decoder);

/**
 * Get the number of detections in a list.
 *
 * @param list Detection box list handle
 * @return Number of detections, or 0 if list is NULL
 */
size_t hal_detect_box_list_len(const struct hal_detect_box_list *list);

/**
 * Get a detection box from a list by index.
 *
 * @param list Detection box list handle
 * @param index Index of the detection (0-based)
 * @param out_box Output parameter for the detection box
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL list/out_box, index out of bounds)
 */
int hal_detect_box_list_get(const struct hal_detect_box_list *list,
                            size_t index,
                            struct hal_detect_box *out_box);

/**
 * Free a detection box list.
 *
 * @param list Detection box list handle to free (can be NULL, no-op)
 */
void hal_detect_box_list_free(struct hal_detect_box_list *list);

/**
 * Get the number of segmentations in a list.
 *
 * @param list Segmentation list handle
 * @return Number of segmentations, or 0 if list is NULL
 */
size_t hal_segmentation_list_len(const struct hal_segmentation_list *list);

/**
 * Get the bounding box of a segmentation by index.
 *
 * @param list Segmentation list handle
 * @param index Index of the segmentation (0-based)
 * @param xmin Output parameter for left coordinate
 * @param ymin Output parameter for top coordinate
 * @param xmax Output parameter for right coordinate
 * @param ymax Output parameter for bottom coordinate
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL list/outputs, index out of bounds)
 */
int hal_segmentation_list_get_bbox(const struct hal_segmentation_list *list,
                                   size_t index,
                                   float *xmin,
                                   float *ymin,
                                   float *xmax,
                                   float *ymax);

/**
 * Get the mask data of a segmentation by index.
 *
 * The returned pointer is borrowed and valid only during the list's lifetime.
 *
 * @param list Segmentation list handle
 * @param index Index of the segmentation (0-based)
 * @param out_height Output parameter for mask height
 * @param out_width Output parameter for mask width
 * @return Pointer to mask data (uint8_t array), or NULL on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL list, index out of bounds)
 */
const uint8_t *hal_segmentation_list_get_mask(const struct hal_segmentation_list *list,
                                              size_t index,
                                              size_t *out_height,
                                              size_t *out_width);

/**
 * Free a segmentation list.
 *
 * @param list Segmentation list handle to free (can be NULL, no-op)
 */
void hal_segmentation_list_free(struct hal_segmentation_list *list);

/**
 * Create a new rectangle.
 *
 * @param left Left edge (x coordinate)
 * @param top Top edge (y coordinate)
 * @param width Width of the rectangle
 * @param height Height of the rectangle
 * @return New rectangle structure
 */
struct hal_rect hal_rect_new(size_t left, size_t top, size_t width, size_t height);

/**
 * Create a new default crop configuration.
 *
 * @return New crop structure with all fields unset
 */
struct hal_crop hal_crop_new(void);

/**
 * Set the source rectangle for a crop configuration.
 *
 * @param crop Crop configuration to modify
 * @param rect Source rectangle (can be NULL to clear)
 */
void hal_crop_set_src_rect(struct hal_crop *crop, const struct hal_rect *rect);

/**
 * Set the destination rectangle for a crop configuration.
 *
 * @param crop Crop configuration to modify
 * @param rect Destination rectangle (can be NULL to clear)
 */
void hal_crop_set_dst_rect(struct hal_crop *crop, const struct hal_rect *rect);

/**
 * Set the background color for a crop configuration.
 *
 * @param crop Crop configuration to modify
 * @param r Red component (0-255)
 * @param g Green component (0-255)
 * @param b Blue component (0-255)
 * @param a Alpha component (0-255)
 */
void hal_crop_set_dst_color(struct hal_crop *crop, uint8_t r, uint8_t g, uint8_t b, uint8_t a);

/**
 * Create a new empty tensor image.
 *
 * @param width Image width in pixels
 * @param height Image height in pixels
 * @param fourcc Pixel format (HAL_FOURCC_*)
 * @param memory Memory allocation type (HAL_TENSOR_DMA recommended)
 * @return New tensor image handle on success, NULL on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (zero dimensions, unsupported format)
 * - ENOMEM: Memory allocation failed
 */
struct hal_tensor_image *hal_tensor_image_new(size_t width,
                                              size_t height,
                                              enum hal_fourcc fourcc,
                                              enum hal_tensor_memory memory);

/**
 * Load an image from memory (JPEG or PNG).
 *
 * Automatically detects format and decodes the image.
 *
 * @param data Pointer to image data
 * @param len Length of image data in bytes
 * @param fourcc Output pixel format (HAL_FOURCC_RGB, HAL_FOURCC_RGBA, or HAL_FOURCC_GREY)
 * @param memory Memory allocation type
 * @return New tensor image handle on success, NULL on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL data, zero length)
 * - EBADMSG: Failed to decode image
 * - ENOMEM: Memory allocation failed
 */
struct hal_tensor_image *hal_tensor_image_load(const uint8_t *data,
                                               size_t len,
                                               enum hal_fourcc fourcc,
                                               enum hal_tensor_memory memory);

/**
 * Load an image from a file (JPEG or PNG).
 *
 * @param path Path to the image file
 * @param fourcc Output pixel format
 * @param memory Memory allocation type
 * @return New tensor image handle on success, NULL on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL path)
 * - ENOENT: File not found
 * - EBADMSG: Failed to decode image
 * - ENOMEM: Memory allocation failed
 */
struct hal_tensor_image *hal_tensor_image_load_file(const char *path,
                                                    enum hal_fourcc fourcc,
                                                    enum hal_tensor_memory memory);

/**
 * Save a tensor image as JPEG.
 *
 * @param image Tensor image to save
 * @param path Output file path
 * @param quality JPEG quality (1-100, 0 for default)
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL image/path)
 * - EIO: Failed to write file
 */
int hal_tensor_image_save_jpeg(const struct hal_tensor_image *image, const char *path, int quality);

/**
 * Free a tensor image.
 *
 * @param image Tensor image handle to free (can be NULL, no-op)
 */
void hal_tensor_image_free(struct hal_tensor_image *image);

/**
 * Get the width of a tensor image.
 *
 * @param image Tensor image handle
 * @return Width in pixels, or 0 if image is NULL
 */
size_t hal_tensor_image_width(const struct hal_tensor_image *image);

/**
 * Get the height of a tensor image.
 *
 * @param image Tensor image handle
 * @return Height in pixels, or 0 if image is NULL
 */
size_t hal_tensor_image_height(const struct hal_tensor_image *image);

/**
 * Get the pixel format of a tensor image.
 *
 * @param image Tensor image handle
 * @return Pixel format, or HAL_FOURCC_RGB if image is NULL
 */
enum hal_fourcc hal_tensor_image_fourcc(const struct hal_tensor_image *image);

/**
 * Clone the file descriptor associated with a tensor image (Linux only).
 *
 * Creates a new owned file descriptor that the caller must close().
 *
 * @param image Tensor image handle
 * @return New file descriptor on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: NULL image
 * - ENOTSUP: Image memory type doesn't support file descriptors
 * - EIO: Failed to clone file descriptor
 */
int hal_tensor_image_clone_fd(const struct hal_tensor_image *image);

/**
 * Clone file descriptor stub for non-Unix platforms.
 */
int hal_tensor_image_clone_fd(const struct hal_tensor_image *image);

/**
 * Get the underlying tensor of a tensor image.
 *
 * The returned tensor is borrowed and valid only during the image's lifetime.
 * Note: This returns an opaque pointer that provides type-erased access.
 *
 * @param image Tensor image handle
 * @return Pointer to the underlying tensor data info, or NULL if image is NULL
 */
const void *hal_tensor_image_tensor(const struct hal_tensor_image *image);

/**
 * Create a new image processor.
 *
 * Automatically selects the best available backend (G2D, OpenGL, or CPU).
 *
 * @return New image processor handle on success, NULL on error
 * @par Errors (errno):
 * - ENOMEM: Memory allocation failed
 * - ENOTSUP: No suitable image processing backend available
 */
struct hal_image_processor *hal_image_processor_new(void);

/**
 * Convert an image to a different format/size.
 *
 * Performs format conversion, scaling, rotation, flip, and crop operations.
 *
 * @param processor Image processor handle
 * @param src Source image
 * @param dst Destination image (must be pre-allocated with desired dimensions)
 * @param rotation Rotation to apply
 * @param flip Flip to apply
 * @param crop Crop configuration (can be NULL for no crop)
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL processor/src/dst)
 * - EIO: Conversion failed
 */
int hal_image_processor_convert(struct hal_image_processor *processor,
                                const struct hal_tensor_image *src,
                                struct hal_tensor_image *dst,
                                enum hal_rotation rotation,
                                enum hal_flip flip,
                                const struct hal_crop *crop);

/**
 * Free an image processor.
 *
 * @param processor Image processor handle to free (can be NULL, no-op)
 */
void hal_image_processor_free(struct hal_image_processor *processor);

/**
 * Create a new tensor with the given data type, shape, and memory type.
 *
 * @param dtype Data type of tensor elements (HAL_DTYPE_*)
 * @param shape Array of dimension sizes (ndim elements)
 * @param ndim Number of dimensions (1-8)
 * @param memory Memory allocation type (HAL_TENSOR_DMA recommended)
 * @param name Optional tensor name for debugging (can be NULL)
 * @return New tensor handle on success, NULL on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL shape, ndim is 0, invalid dtype)
 * - ENOMEM: Memory allocation failed
 * - EIO: DMA heap not available (falls back to SHM/MEM)
 */
struct hal_tensor *hal_tensor_new(enum hal_dtype dtype,
                                  const size_t *shape,
                                  size_t ndim,
                                  enum hal_tensor_memory memory,
                                  const char *name);

/**
 * Create a new tensor from an existing file descriptor (Linux only).
 *
 * Takes ownership of the file descriptor - caller must NOT close it.
 *
 * @param dtype Data type of tensor elements (HAL_DTYPE_*)
 * @param fd File descriptor for DMA/SHM buffer (ownership transferred)
 * @param shape Array of dimension sizes (ndim elements)
 * @param ndim Number of dimensions (1-8)
 * @param name Optional tensor name for debugging (can be NULL)
 * @return New tensor handle on success, NULL on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL shape, ndim is 0, invalid fd)
 * - ENOMEM: Memory allocation failed
 * - ENOTSUP: Not supported on this platform (non-Unix)
 */
struct hal_tensor *hal_tensor_from_fd(enum hal_dtype dtype,
                                      int fd,
                                      const size_t *shape,
                                      size_t ndim,
                                      const char *name);

/**
 * Create a new tensor from an existing file descriptor (stub for non-Unix).
 */
struct hal_tensor *hal_tensor_from_fd(enum hal_dtype dtype,
                                      int fd,
                                      const size_t *shape,
                                      size_t ndim,
                                      const char *name);

/**
 * Free a tensor and release its resources.
 *
 * After calling this function, the tensor pointer becomes invalid.
 *
 * @param tensor Tensor handle to free (can be NULL, no-op)
 */
void hal_tensor_free(struct hal_tensor *tensor);

/**
 * Get the data type of a tensor.
 *
 * @param tensor Tensor handle
 * @return Data type enum value, or HAL_DTYPE_U8 if tensor is NULL
 */
enum hal_dtype hal_tensor_dtype(const struct hal_tensor *tensor);

/**
 * Get the size in bytes of the tensor's data type.
 *
 * @param tensor Tensor handle
 * @return Size of one element in bytes, or 0 if tensor is NULL
 */
size_t hal_tensor_dtype_size(const struct hal_tensor *tensor);

/**
 * Get the memory allocation type of a tensor.
 *
 * @param tensor Tensor handle
 * @return Memory type enum value, or HAL_TENSOR_MEM if tensor is NULL
 */
enum hal_tensor_memory hal_tensor_memory_type(const struct hal_tensor *tensor);

/**
 * Get the name of a tensor.
 *
 * The returned string is owned by the caller and must be freed with free().
 *
 * @param tensor Tensor handle
 * @return Newly allocated C string with tensor name, or NULL on error
 */
char *hal_tensor_name(const struct hal_tensor *tensor);

/**
 * Get the shape of a tensor.
 *
 * The returned pointer is borrowed and valid only during the tensor's lifetime.
 *
 * @param tensor Tensor handle
 * @param out_ndim Output parameter for number of dimensions (can be NULL)
 * @return Pointer to shape array, or NULL if tensor is NULL
 */
const size_t *hal_tensor_shape(const struct hal_tensor *tensor, size_t *out_ndim);

/**
 * Get the total number of elements in a tensor.
 *
 * @param tensor Tensor handle
 * @return Number of elements (product of all dimensions), or 0 if tensor is NULL
 */
size_t hal_tensor_len(const struct hal_tensor *tensor);

/**
 * Get the total size in bytes of a tensor's data.
 *
 * @param tensor Tensor handle
 * @return Size in bytes (len * dtype_size), or 0 if tensor is NULL
 */
size_t hal_tensor_size(const struct hal_tensor *tensor);

/**
 * Clone the file descriptor associated with a tensor (Linux only).
 *
 * Creates a new owned file descriptor that the caller must close().
 *
 * @param tensor Tensor handle
 * @return New file descriptor on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: NULL tensor
 * - ENOTSUP: Tensor memory type doesn't support file descriptors, or non-Unix
 * - EIO: Failed to clone file descriptor
 */
int hal_tensor_clone_fd(const struct hal_tensor *tensor);

/**
 * Clone file descriptor stub for non-Unix platforms.
 */
int hal_tensor_clone_fd(const struct hal_tensor *tensor);

/**
 * Reshape a tensor to a new shape.
 *
 * The total number of elements must remain the same.
 *
 * @param tensor Tensor handle
 * @param shape New shape array
 * @param ndim Number of dimensions in new shape
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: NULL tensor/shape, ndim is 0, or element count mismatch
 */
int hal_tensor_reshape(struct hal_tensor *tensor, const size_t *shape, size_t ndim);

/**
 * Map a tensor for CPU access.
 *
 * This function maps the tensor's memory for CPU read/write operations.
 * For DMA tensors, this includes automatic cache synchronization.
 * The returned map must be unmapped with hal_tensor_map_unmap() when done.
 *
 * @param tensor Tensor handle
 * @return Tensor map handle on success, NULL on error
 * @par Errors (errno):
 * - EINVAL: NULL tensor
 * - EIO: Failed to map tensor memory
 */
struct hal_tensor_map *hal_tensor_map_create(const struct hal_tensor *tensor);

/**
 * Get a mutable pointer to the mapped tensor data.
 *
 * The returned pointer is valid only while the map exists.
 * Cast the void* to the appropriate type based on hal_tensor_dtype().
 *
 * @param map Tensor map handle
 * @return Pointer to data, or NULL if map is NULL
 */
void *hal_tensor_map_data(struct hal_tensor_map *map);

/**
 * Get a const pointer to the mapped tensor data.
 *
 * The returned pointer is valid only while the map exists.
 * Cast the void* to the appropriate type based on hal_tensor_dtype().
 *
 * @param map Tensor map handle
 * @return Pointer to data, or NULL if map is NULL
 */
const void *hal_tensor_map_data_const(const struct hal_tensor_map *map);

/**
 * Get the shape of a mapped tensor.
 *
 * @param map Tensor map handle
 * @param out_ndim Output parameter for number of dimensions (can be NULL)
 * @return Pointer to shape array, or NULL if map is NULL
 */
const size_t *hal_tensor_map_shape(const struct hal_tensor_map *map, size_t *out_ndim);

/**
 * Get the total number of elements in a mapped tensor.
 *
 * @param map Tensor map handle
 * @return Number of elements, or 0 if map is NULL
 */
size_t hal_tensor_map_len(const struct hal_tensor_map *map);

/**
 * Get the total size in bytes of mapped tensor data.
 *
 * @param map Tensor map handle
 * @return Size in bytes, or 0 if map is NULL
 */
size_t hal_tensor_map_size(const struct hal_tensor_map *map);

/**
 * Unmap a tensor and release the mapping.
 *
 * For DMA tensors, this includes automatic cache synchronization.
 * After calling this function, the map pointer becomes invalid.
 *
 * @param map Tensor map handle to unmap (can be NULL, no-op)
 */
void hal_tensor_map_unmap(struct hal_tensor_map *map);

/**
 * Create a new ByteTrack tracker with specified parameters.
 *
 * @param track_thresh Score threshold for creating new tracks
 * @param high_thresh High confidence threshold for first-pass matching
 * @param match_thresh IOU threshold for matching detections to tracks
 * @param frame_rate Expected frame rate of the input video
 * @param track_buffer Number of frames to keep lost tracks before deletion
 * @return New ByteTrack handle on success, NULL on error
 * @par Errors (errno):
 * - ENOMEM: Memory allocation failed
 */
struct hal_bytetrack *hal_bytetrack_new(float track_thresh,
                                        float high_thresh,
                                        float match_thresh,
                                        int frame_rate,
                                        int track_buffer);

/**
 * Create a new ByteTrack tracker with default parameters.
 *
 * Default values:
 * - track_thresh: 0.25
 * - high_thresh: 0.7
 * - match_thresh: 0.25
 * - track_extra_lifespan: 500ms
 *
 * @return New ByteTrack handle on success, NULL on error
 * @par Errors (errno):
 * - ENOMEM: Memory allocation failed
 */
struct hal_bytetrack *hal_bytetrack_new_default(void);

/**
 * Update the tracker with new detections.
 *
 * @param tracker ByteTrack handle
 * @param detections Detection box list from decoder
 * @param timestamp Current timestamp in nanoseconds
 * @return Track info list with updated tracks (caller must free), NULL on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL tracker/detections)
 */
struct hal_track_info_list *hal_bytetrack_update(struct hal_bytetrack *tracker,
                                                 const struct hal_detect_box_list *detections,
                                                 uint64_t timestamp);

/**
 * Get all currently active tracks.
 *
 * @param tracker ByteTrack handle
 * @return Track info list (caller must free), NULL on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL tracker)
 */
struct hal_track_info_list *hal_bytetrack_get_active_tracks(const struct hal_bytetrack *tracker);

/**
 * Free a ByteTrack tracker.
 *
 * @param tracker ByteTrack handle to free (can be NULL, no-op)
 */
void hal_bytetrack_free(struct hal_bytetrack *tracker);

/**
 * Get the number of tracks in a list.
 *
 * @param list Track info list handle
 * @return Number of tracks, or 0 if list is NULL
 */
size_t hal_track_info_list_len(const struct hal_track_info_list *list);

/**
 * Get a track info from a list by index.
 *
 * @param list Track info list handle
 * @param index Index of the track (0-based)
 * @param out_info Output parameter for the track info
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL list/out_info, index out of bounds)
 */
int hal_track_info_list_get(const struct hal_track_info_list *list,
                            size_t index,
                            struct hal_track_info *out_info);

/**
 * Free a track info list.
 *
 * @param list Track info list handle to free (can be NULL, no-op)
 */
void hal_track_info_list_free(struct hal_track_info_list *list);

/**
 * Convert a UUID byte array to a string representation.
 *
 * The output buffer must be at least 37 bytes (36 chars + null terminator).
 *
 * @param uuid UUID byte array (16 bytes)
 * @param out_str Output buffer for string representation
 * @param out_len Size of output buffer
 * @return 0 on success, -1 on error
 * @par Errors (errno):
 * - EINVAL: Invalid argument (NULL pointers, buffer too small)
 */
int hal_uuid_to_string(const uint8_t (*uuid)[16], char *out_str, size_t out_len);

#ifdef __cplusplus
}
#endif

#endif /* EDGEFIRST_HAL_H */
