# AI Assistant Development Guidelines

**Purpose:** Instructions for AI coding assistants (GitHub Copilot, Cursor, Claude Code, etc.) working on this project.

**Version:** 1.1
**Last Updated:** February 2026

---

## Git Workflow

### Branch Naming

**Format:** `<type>/<PROJECTKEY-###>[-optional-description]`

```bash
feature/EDGEAI-123-add-authentication
bugfix/STUDIO-456-fix-memory-leak
hotfix/MAIVIN-789-security-patch
```

- JIRA key is **required** for feature/bugfix/hotfix branches (format: `PROJECTKEY-###`)
- Description is optional but recommended
- Use kebab-case for descriptions

### Commit Messages

**For feature/bug work (with JIRA ticket):**
```bash
EDGEAI-123: Add JWT authentication to user API
STUDIO-456: Fix memory leak in CUDA kernel allocation
```

**For housekeeping (no JIRA ticket required):**
Housekeeping commits do not require a JIRA key. These include:
- Releases and version bumps
- CI/CD fixes and improvements
- Documentation improvements
- Code formatting or linting fixes
- Dependency updates
- Refactoring without functional changes

Examples:
```bash
Release v0.6.0
Update CI workflow to use latest actions
Fix typo in README
Format code with rustfmt
Update dependencies
```

**Guidelines:**
- Subject line: 50-72 characters
- Focus on WHAT changed, not HOW
- Use `-s` flag for signed-off-by when committing

### Pull Requests

- **2 approvals** required for `main`
- **1 approval** required for `develop`
- All CI/CD checks must pass
- PR title: `PROJECTKEY-### Brief description` (or descriptive title for housekeeping)
- Link to JIRA ticket in description (when applicable)

---

## Release Process

### Overview

This project uses semantic versioning (MAJOR.MINOR.PATCH) with automated publishing to crates.io and PyPI via GitHub Actions when version tags are pushed.

### Pre-Release Checklist

Before creating a release, ensure:

1. **All changes are merged** to `main` branch
2. **CI/CD passes** on the latest `main` commit
3. **CHANGELOG.md** is updated with the new version section
4. **Version numbers** are consistent across all files

### Release Steps

#### 1. Update Version Numbers

Update the version in these files:
- `Cargo.toml` - workspace version under `[workspace.package]`
- `crates/python/pyproject.toml` - Python package version
- `Cargo.lock` - regenerated by cargo

```bash
# Example: Update to version 0.6.0
# Edit Cargo.toml [workspace.package] section: version = "0.6.0"
# Edit crates/python/pyproject.toml: version = "0.6.0"
# Run cargo check to update Cargo.lock
cargo check --workspace
```

#### 2. Update CHANGELOG.md

Move items from `[Unreleased]` to a new version section:

```markdown
## [Unreleased]

## [0.6.0] - 2026-02-15

### Added
- New feature X

### Changed
- Updated behavior Y

### Fixed
- Bug fix Z
```

#### 3. Regenerate NOTICE File

If dependencies changed, regenerate the NOTICE file:

```bash
make sbom
python3 .github/scripts/generate_notice.py
```

#### 4. Verify Version Consistency

Run the version verification script:

```bash
python3 .github/scripts/verify_version.py
```

This checks:
- Cargo.toml workspace version
- Cargo.toml internal dependency versions
- Cargo.lock versions for all workspace crates
- crates/python/pyproject.toml Python package version
- CHANGELOG.md has an entry for the version
- NOTICE has correct versions (no stale entries)

#### 5. Run Pre-Release Checks

```bash
make format lint check
```

Or run the full pre-release target:

```bash
make pre-release
```

#### 6. Commit the Release

```bash
git add -A
git commit -s -m "Release v0.6.0"
```

The `-s` flag adds a signed-off-by line.

#### 7. Create and Push Tag

```bash
git tag -a -s v0.6.0 -m "Version 0.6.0

Highlights:
- Feature X
- Improvement Y
- Bug fix Z

See CHANGELOG.md for full details."
```

The `-a` flag creates an annotated tag, `-s` signs it with GPG.

#### 8. Push Changes

```bash
git push origin main
git push origin v0.6.0
```

### Post-Release

The `release.yml` workflow automatically:
- Builds Python wheels for Linux, Windows, and macOS
- Publishes to PyPI (stable releases only)
- Publishes Rust crates to crates.io
- Creates a GitHub Release with changelog

### Release Candidates

For pre-release versions, use the `rcN` suffix:

```bash
git tag -a -s v0.6.0rc1 -m "Version 0.6.0 Release Candidate 1"
```

Release candidates are published to PyPI but marked as pre-release.

---

## Code Quality

### General Principles

- **Consistency:** Follow existing codebase patterns
- **Readability:** Code is read more than written
- **Simplicity:** Prefer straightforward solutions
- **Error Handling:** Validate inputs, provide clear error messages
- **Performance:** Consider time/space complexity for edge deployment

### Language Standards

- **Rust:** `cargo fmt` and `cargo clippy`
- **Python:** PEP 8, type hints preferred, use `ruff` for formatting/linting

### SonarQube Integration

If project has `sonar-project.properties`:
- Address critical and high-severity issues before PR
- Maintain or improve quality gate scores
- Use SonarLint VSCode plugin for real-time feedback

---

## Testing Requirements

### Coverage Standards

- **Minimum:** 70% (check project-specific thresholds)
- **Critical paths:** 90%+ coverage
- **Edge cases:** Explicit tests for boundary conditions
- **Error paths:** Validate error handling

### Test Organization

**Rust:**
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_process_data_valid_input() {
        // test implementation
    }
}
```

**Python:**
```
tests/
├── unit/test_module.py
└── integration/test_api_workflow.py
```

### Running Tests

```bash
make test          # Run all tests
cargo test         # Rust only
pytest tests/      # Python only
```

---

## License Policy

**CRITICAL:** Strict license policy for all dependencies.

### ✅ Allowed Licenses

- MIT, Apache-2.0, BSD-2/3-Clause, ISC, 0BSD, Unlicense

### ⚠️ Review Required

- MPL-2.0 (file-level copyleft - dependencies only, NOT embedded source)
- LGPL-2.1/3.0 (if dynamically linked)

### ❌ Disallowed Licenses

- GPL (any version)
- AGPL (any version)
- Creative Commons with NC/ND restrictions
- SSPL, BSL, OSL-3.0

**CI/CD automatically:**
- Generates SBOM using scancode-toolkit
- Validates license compliance
- **Blocks PR merges on violations**

---

## Security Practices

### Vulnerability Reporting

- Email: `support@au-zone.com` (subject: "Security Vulnerability")
- Expected acknowledgment: 48 hours
- See project's `SECURITY.md` for full process

### Secure Coding

- Never hardcode credentials or API keys
- Use environment variables or secure vaults
- Validate all external inputs
- Follow principle of least privilege

---

## EdgeFirst HAL Project-Specific Guidelines

### Project Overview

EdgeFirst HAL is a Rust-based hardware abstraction layer with Python bindings, providing zero-copy memory management, hardware-accelerated image processing, and ML model post-processing for embedded Linux platforms.

### Technology Stack

- **Language:** Rust 1.70+ with Python 3.8+ bindings
- **Build system:** Cargo workspace, maturin for Python
- **Key dependencies:** ndarray, rayon, pyo3, enum_dispatch
- **Target platforms:** Linux x86_64, ARM64 (NXP i.MX, generic embedded)

### Workspace Structure

```
crates/
├── tensor/     # Zero-copy tensor abstractions
├── image/      # Hardware-accelerated image processing
├── decoder/    # YOLO and model output decoding
├── tracker/    # Object tracking algorithms
├── hal/        # Top-level re-export crate
├── capi/       # C API bindings (cbindgen)
└── python/     # PyO3 Python bindings
```

### Naming Conventions

**Rust Types:**
- Core types: `Tensor<T>`, `TensorImage`, `ImageProcessor`, `Decoder`
- Trait names: `TensorTrait<T>`, `ImageProcessorTrait`
- Enum variants: PascalCase (e.g., `DmaTensor`, `ShmTensor`, `MemTensor`)

**Python Wrapper Types:**
- Use `Py` prefix: `PyTensor`, `PyTensorImage`, `PyImageProcessor`
- Located in `crates/python/src/`

### Memory Management Pattern

The HAL uses a fallback chain for memory allocation:

```rust
// Automatic fallback: DMA → Shared Memory → Heap
let tensor = Tensor::<u8>::new(&[height, width, channels], None)?;

// Explicit type selection
let tensor = Tensor::<u8>::new(&[height, width, channels], Some(TensorType::Dma))?;
```

- `DmaTensor<T>`: Linux DMA-heap for zero-copy hardware access
- `ShmTensor<T>`: POSIX shared memory for IPC
- `MemTensor<T>`: Standard heap allocation as fallback
- Environment variable `EDGEFIRST_TENSOR_FORCE_MEM=1` forces heap allocation

### Error Handling

All public APIs return `Result<T, E>` with specific error types:
- `TensorError` for tensor operations
- `ImageError` for image processing
- `DecoderError` for model decoding

### Hardware Acceleration Pattern

Image processing uses a fallback chain: G2D → OpenGL → CPU

```rust
impl ImageProcessorTrait for ImageProcessor {
    fn convert(&mut self, src: &TensorImage, dst: &mut TensorImage) -> Result<()> {
        if let Some(g2d) = &mut self.g2d {
            if g2d.can_convert(src.format, dst.format) {
                return g2d.convert(src, dst, options);
            }
        }
        self.cpu.convert(src, dst, options)
    }
}
```

### Cross-Compilation with zigbuild

**Always cross-compile for aarch64 using `cargo-zigbuild` during development.**
The project targets ARM64 embedded Linux (NXP i.MX 8M Plus). Do not use a
`.cargo/config.toml` with Yocto SDK linker settings — zigbuild provides its own
linker and sysroot via Zig.

```bash
# Build all crates for aarch64
cargo-zigbuild zigbuild --target aarch64-unknown-linux-gnu --release --workspace

# Cross-compile unit tests (without running them)
cargo-zigbuild test --target aarch64-unknown-linux-gnu --release --no-run \
    --workspace --exclude edgefirst_hal

# Run tests on target hardware (after scp to the device)
ssh <target> 'cd /tmp/hal-tests && ./edgefirst_image-<hash> --test-threads=1'
```

The Python crate (`edgefirst_hal`) must be excluded from zigbuild cross-compilation
because PyO3 requires `PYO3_CROSS_PYTHON_VERSION` or a target Python installation.
Python wheels are built separately via `maturin` in CI.

### Pre-Commit Verification (MANDATORY)

**Before every commit, you MUST run the full verification suite and confirm
all steps pass. Never commit with failing checks.**

```bash
make format lint check test sbom
```

This runs, in order:
1. **format** — `cargo +nightly fmt --all` and `ruff format`
2. **lint** — `cargo clippy -- -D warnings` and `ruff check`
3. **check** — `cargo check --all-features --workspace`
4. **test** — Rust tests with coverage (`cargo llvm-cov nextest`) and Python tests
5. **sbom** — SBOM generation and license policy validation

If any step fails, fix the issue before committing. Do not skip or ignore
failures. This mirrors what CI/CD runs and prevents broken pipelines.

### Build and Test Commands

```bash
# MANDATORY before committing (see above)
make format lint check test sbom

# Build all crates (native, for local development)
cargo build --workspace

# Test all Rust code (native)
cargo test --workspace

# Cross-compile for aarch64 (preferred for development)
cargo-zigbuild zigbuild --target aarch64-unknown-linux-gnu --release --workspace

# Build Python bindings
maturin develop -m crates/python/Cargo.toml

# Test Python bindings
python -m pytest tests/

# Format code
cargo +nightly fmt --all

# Lint
cargo clippy --workspace

# Run benchmarks
cargo bench -p edgefirst_image
```

### Common Tasks

**Adding a New Tensor Operation:**
1. Add method to `TensorTrait<T>` in `crates/tensor/src/lib.rs`
2. Implement for `DmaTensor`, `ShmTensor`, `MemTensor`
3. Add Python binding in `crates/python/src/tensor.rs`
4. Add test in `tests/test_tensor.py`
5. Update type stubs in `crates/python/edgefirst_hal.pyi`

**Adding a New Image Format:**
1. Add FourCC variant in dependency `four-char-code`
2. Update format conversion logic in `crates/image/src/`
3. Add G2D support (if hardware supports it)
4. Add CPU fallback
5. Add Python tests

### Code Style

**Rust:**
- Use `rustfmt` configuration in `rustfmt.toml`
- Prefer `?` over `unwrap()` in production code
- Use `Result<T, E>` for all fallible operations
- Document public APIs with `///` doc comments

**Python:**
- Follow PEP 8 style guide
- Use type hints in `.pyi` stub files
- Match Python naming (snake_case functions, PascalCase classes)

### Platform Considerations

- **Linux (NXP i.MX)**: Full hardware acceleration via G2D
- **Linux (Generic)**: DMA-heap and OpenGL available
- **macOS/Windows**: CPU-only fallback paths

When adding features:
- Always provide CPU fallback
- Use feature flags for optional hardware support
- Test on multiple platforms if possible

### Common Pitfalls

1. **Don't mix tensor types unnecessarily** - Use `None` for automatic selection
2. **Don't forget CPU fallbacks** - Hardware acceleration may not be available
3. **Don't unwrap in library code** - Always return `Result` for errors
4. **Don't forget Python type stubs** - Update `.pyi` when adding Python APIs
5. **Don't skip tests** - Add both Rust and Python tests for new features
6. **Don't forget documentation** - Public APIs need doc comments

---

## Documentation Standards

All public APIs must include:
```rust
/// Brief one-line description.
///
/// More detailed explanation if needed.
///
/// # Arguments
///
/// * `arg1` - Description
/// * `arg2` - Description
///
/// # Returns
///
/// Description of return value
///
/// # Errors
///
/// When this function returns an error and why
///
/// # Examples
///
/// ```rust
/// use edgefirst_hal::tensor::Tensor;
///
/// let tensor = Tensor::<u8>::new(&[640, 480, 3], None)?;
/// ```
pub fn function_name(arg1: Type1, arg2: Type2) -> Result<ReturnType> {
    // Implementation
}
```

---

## Working with AI Assistants

### Best Practices

- Verify suggestions match project conventions
- Run linters after accepting suggestions
- Ensure meaningful test assertions
- Follow security best practices

### Common Pitfalls

- **Hallucinated APIs:** Verify library functions exist
- **Outdated patterns:** Check current best practices
- **Over-engineering:** Prefer simple solutions
- **Missing edge cases:** Explicitly test boundaries
- **License violations:** AI may suggest incompatible code

---

## Getting Help

**Development questions:**
- Check `CONTRIBUTING.md` for setup instructions
- Review existing code for patterns
- Search GitHub Issues
- Ask in GitHub Discussions

**Security concerns:**
- Email: `support@au-zone.com` (subject: "Security Vulnerability")
- Do not disclose publicly

---

## Quick Reference

| Item | Format |
|------|--------|
| Branch | `feature/JIRA-123-description` |
| Commit (feature) | `JIRA-123: Brief description` |
| Commit (housekeeping) | `Release v0.6.0` or descriptive message |
| PR approvals | 2 for main, 1 for develop |
| Allowed licenses | MIT, Apache-2.0, BSD |
| Disallowed licenses | GPL, AGPL |
| Test coverage | 70% minimum |
| Security contact | `support@au-zone.com` |

---

*This document helps AI assistants contribute effectively while maintaining quality, security, and consistency.*
